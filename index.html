<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jard√≠n de Noath</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #f0f4f8;
        }
        canvas {
            cursor: crosshair;
        }
        button {
            transition: all 0.3s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
        }
        .garden-title {
            font-family: 'Dancing Script', cursive;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            transition: color 0.5s ease-in-out;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen w-screen relative">

    <!-- Contenedor del Canvas que ocupa toda la pantalla -->
    <div class="absolute inset-0">
        <canvas id="flowerCanvas" class="w-full h-full"></canvas>
    </div>

    <!-- Contenedor de los botones flotantes en la esquina superior izquierda -->
    <div class="absolute top-4 left-4 z-10 flex space-x-2">
        <button id="clearButton" class="bg-white text-gray-800 py-2 px-4 rounded-full text-lg">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
        </button>
        <button id="rainButton" class="bg-white text-gray-800 py-2 px-4 rounded-full text-lg">
            üíß
        </button>
        <button id="windButton" class="bg-white text-gray-800 py-2 px-4 rounded-full text-lg">
            üå¨Ô∏è
        </button>
        <button id="downloadButton" class="bg-white text-gray-800 py-2 px-4 rounded-full text-lg">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
        </button>
    </div>

    <!-- Contenedor para el t√≠tulo -->
    <div class="absolute top-4 right-4 z-10 text-right">
        <h1 id="gardenTitle" class="text-xl md:text-2xl font-bold garden-title">Jard√≠n de Noath</h1>
    </div>

    <script>
        const canvas = document.getElementById('flowerCanvas');
        const ctx = canvas.getContext('2d');
        const clearButton = document.getElementById('clearButton');
        const rainButton = document.getElementById('rainButton');
        const windButton = document.getElementById('windButton');
        const downloadButton = document.getElementById('downloadButton');
        const gardenTitle = document.getElementById('gardenTitle');

        let flowers = [];
        let clouds = [];
        let stars = [];
        let raindrops = [];
        let fauna = [];
        let currentAnimation = null;
        let dayNightProgress = 0;
        let sunriseTime = null;
        let sunsetTime = null;
        let time = 0;
        let isRaining = false;
        let isWindy = false;
        let faunaSpawnTimer = 0;
        const FAUNA_SPAWN_INTERVAL = 3000;
        const REGENERATION_PROBABILITY = 0.0005;
        const WILT_SPEED = 0.005;

        // Variables de color para la transici√≥n
        const daySkyColor = {r: 135, g: 206, b: 235}; // #87CEEB
        const nightSkyColor = {r: 25, g: 25, b: 112}; // #191970
        const sunriseSkyColor = {r: 255, g: 140, b: 0}; // #FF8C00
        const sunsetSkyColor = {r: 255, g: 69, b: 0}; // #FF4500
        const dayGroundColor = {r: 160, g: 82, b: 45}; // #A0522D
        const nightGroundColor = {r: 47, g: 27, b: 19}; // #2F1B13
        
        // Colores de p√©talos y color marchito
        const petalColors = [
            '#FFC0CB', '#FF69B4', '#DB7093', '#C71585',
            '#ADD8E6', '#87CEEB', '#00BFFF', '#1E90FF',
            '#98FB98', '#90EE90', '#2E8B57', '#008000',
            '#FFFF00', '#FFD700', '#FFA500', '#FF8C00',
            '#800080', '#9400D3', '#DA70D6', '#BA55D3',
            '#6A0DAD', '#4B0082', '#9932CC', '#DDA0DD',
            '#FF4500', '#FF6347', '#FF8C00', '#FA8072',
            '#FFFFFF', '#F5F5F5', '#E0E0E0', '#D3D3D3'
        ];
        const witheredColor = {r: 64, g: 64, b: 64}; // Color gris oscuro

        // Inicializaci√≥n de sonidos
        const reverb = new Tone.Reverb(2).toDestination();
        const rainSynth = new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 1,
            envelope: {
                attack: 0.001,
                decay: 0.4,
                sustain: 0.01,
                release: 0.4
            }
        }).toDestination();
        rainSynth.volume.value = -10;

        const windSynth = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: {
                attack: 0.1,
                decay: 0.5,
                sustain: 1.0,
                release: 0.5
            }
        }).toDestination();
        windSynth.volume.value = -30;
        
        let rainInterval = null;

        function playRainSound() {
            if (isRaining) {
                rainInterval = setInterval(() => {
                    rainSynth.triggerAttackRelease("C2", "0.1s");
                }, 100);
            } else if (rainInterval) {
                clearInterval(rainInterval);
                rainInterval = null;
            }
        }

        function toggleWindSound() {
            if (isWindy) {
                windSynth.triggerAttack();
            } else {
                windSynth.triggerRelease();
            }
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawAll();
        }

        function showLoading(show) {
            // No es necesario por ahora
        }

        async function getSunriseSunset() {
            const url = 'https://api.sunrisesunset.io/json?lat=6.244203&lng=-75.581211';

            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.status === 'OK') {
                    const today = new Date();
                    const sunriseString = data.results.sunrise;
                    const sunsetString = data.results.sunset;
                    
                    sunriseTime = new Date(today.toDateString() + ' ' + sunriseString);
                    sunsetTime = new Date(today.toDateString() + ' ' + sunsetString);
                    
                    if (sunsetTime.getTime() < sunriseTime.getTime()) {
                        sunsetTime.setDate(sunsetTime.getDate() + 1);
                    }
                    updateDayNightProgress();
                } else {
                    console.error('Error al obtener la hora del amanecer y atardecer:', data.status);
                }
            } catch (error) {
                console.error('Fallo en la llamada a la API:', error);
            }
        }

        function updateDayNightProgress() {
            if (!sunriseTime || !sunsetTime) return;

            const now = new Date();
            const nowMs = now.getTime();
            const sunriseMs = sunriseTime.getTime();
            const sunsetMs = sunsetTime.getTime();
            
            let dayDurationMs;
            let nightDurationMs;

            if (sunriseMs < sunsetMs) {
                dayDurationMs = sunsetMs - sunriseMs;
                nightDurationMs = (24 * 60 * 60 * 1000) - dayDurationMs;
            } else {
                dayDurationMs = (sunsetMs + 24 * 60 * 60 * 1000) - sunriseMs;
                nightDurationMs = (24 * 60 * 60 * 1000) - dayDurationMs;
            }

            if (nowMs >= sunriseMs && nowMs < sunsetMs) {
                dayNightProgress = (nowMs - sunriseMs) / dayDurationMs;
            } else {
                let currentNightStart;
                if (nowMs < sunriseMs) {
                    currentNightStart = new Date(sunsetTime);
                    currentNightStart.setDate(currentNightStart.getDate() - 1);
                } else {
                    currentNightStart = sunsetTime;
                }
                dayNightProgress = 1 + (nowMs - currentNightStart.getTime()) / nightDurationMs;
            }
        }

        function drawSunMoon() {
            const radius = 60;
            let objectColor, shadowColor;
            let progress;

            if (dayNightProgress <= 1) {
                progress = dayNightProgress;
                objectColor = '#FFD700';
                shadowColor = 'rgba(255, 215, 0, 0.5)';
            } else {
                progress = dayNightProgress - 1;
                objectColor = '#f0f0f0';
                shadowColor = 'rgba(240, 240, 240, 0.5)';
            }

            const sunMoonX = canvas.width * progress;
            const sunMoonY = canvas.height * 0.75 - Math.sin(progress * Math.PI) * (canvas.height * 0.65);

            ctx.beginPath();
            ctx.arc(sunMoonX, sunMoonY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = objectColor;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 40;
            ctx.fill();
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function drawCloud(cloud) {
            const { x, y, scale } = cloud;
            ctx.fillStyle = 'white';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(x, y, 40 * scale, 0, 2 * Math.PI);
            ctx.arc(x + 40 * scale, y, 30 * scale, 0, 2 * Math.PI);
            ctx.arc(x + 70 * scale, y + 20 * scale, 25 * scale, 0, 2 * Math.PI);
            ctx.arc(x + 20 * scale, y + 20 * scale, 25 * scale, 0, 2 * Math.PI);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
        
        function drawStar(star) {
            const { x, y, size, opacity } = star;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, 2 * Math.PI);
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fill();
        }

        function drawBackground() {
            function interpolateColor(color1, color2, factor) {
                const result = {};
                result.r = Math.round(color1.r + factor * (color2.r - color1.r));
                result.g = Math.round(color1.g + factor * (color2.g - color1.g));
                result.b = Math.round(color1.b + factor * (color2.b - color1.b));
                return `rgb(${result.r}, ${result.g}, ${result.b})`;
            }

            let skyColor, groundColor;
            if (dayNightProgress >= 0 && dayNightProgress < 0.25) {
                const progress = dayNightProgress / 0.25;
                skyColor = interpolateColor(nightSkyColor, sunriseSkyColor, progress);
                groundColor = interpolateColor(nightGroundColor, dayGroundColor, progress);
            } else if (dayNightProgress >= 0.25 && dayNightProgress < 0.75) {
                const progress = (dayNightProgress - 0.25) / 0.5;
                skyColor = interpolateColor(sunriseSkyColor, daySkyColor, progress);
                groundColor = interpolateColor(dayGroundColor, dayGroundColor, progress);
            } else if (dayNightProgress >= 0.75 && dayNightProgress < 1) {
                const progress = (dayNightProgress - 0.75) / 0.25;
                skyColor = interpolateColor(daySkyColor, sunsetSkyColor, progress);
                groundColor = interpolateColor(dayGroundColor, nightGroundColor, progress);
            } else {
                skyColor = `rgb(${nightSkyColor.r}, ${nightSkyColor.g}, ${nightSkyColor.b})`;
                groundColor = `rgb(${nightGroundColor.r}, ${nightGroundColor.g}, ${nightGroundColor.b})`;
            }
            
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.75);
            skyGradient.addColorStop(0, skyColor);
            skyGradient.addColorStop(1, skyColor);
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height * 0.75);

            const groundGradient = ctx.createLinearGradient(0, canvas.height * 0.75, 0, canvas.height);
            groundGradient.addColorStop(0, groundColor);
            groundGradient.addColorStop(1, groundColor);
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height * 0.75, canvas.width, canvas.height);
        }

        function moveClouds() {
            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > canvas.width + 100) {
                    cloud.x = -150;
                    cloud.y = Math.random() * (canvas.height * 0.3);
                }
            });
        }

        function generateClouds() {
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * 0.3),
                    scale: Math.random() * 0.8 + 0.5,
                    speed: Math.random() * 0.2 + 0.1
                });
            }
        }
        
        function generateStars() {
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * 0.7),
                    size: Math.random() * 2 + 1,
                    opacity: 0
                });
            }
        }

        function animateStars() {
            let targetOpacity = 0;
            if (dayNightProgress >= 1 || dayNightProgress < 0.25) {
                targetOpacity = 1;
            }

            stars.forEach(star => {
                if (targetOpacity === 1) {
                    star.opacity = Math.min(1, star.opacity + 0.01);
                } else {
                    star.opacity = Math.max(0, star.opacity - 0.01);
                }
            });
        }

        // Funci√≥n para interpolar entre dos colores
        function interpolateRGB(rgb1, rgb2, factor) {
            const result = {};
            result.r = Math.round(rgb1.r + factor * (rgb2.r - rgb1.r));
            result.g = Math.round(rgb1.g + factor * (rgb2.g - rgb1.g));
            result.b = Math.round(rgb1.b + factor * (rgb2.b - rgb1.b));
            return `rgb(${result.r}, ${result.g}, ${result.b})`;
        }
        
        function drawFlower(flower, time) {
            const { x, y, stemHeight, petalColor, centerRadius, centerColor, numPetals, petalLength, petalWidth, petalShape, progress, wiltProgress } = flower;

            const windEffect = isWindy ? Math.sin(time * 0.005 + x / 100) * 15 : 0;
            const swayOffset = Math.sin(time * 0.002 + x) * 5 + windEffect;
            
            // Interpolamos el color de los p√©talos
            const originalRGB = {
                r: parseInt(petalColor.substring(1, 3), 16),
                g: parseInt(petalColor.substring(3, 5), 16),
                b: parseInt(petalColor.substring(5, 7), 16)
            };
            const currentPetalColor = interpolateRGB(originalRGB, witheredColor, wiltProgress);

            // Interpolamos el color y tama√±o del tallo y p√©talos
            const stemHeightScaled = stemHeight * (1 - wiltProgress);
            const petalLengthScaled = petalLength * (1 - wiltProgress);
            const petalWidthScaled = petalWidth * (1 - wiltProgress);
            const centerRadiusScaled = centerRadius * (1 - wiltProgress);

            // Tallo
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + swayOffset, y - stemHeightScaled * progress);
            ctx.strokeStyle = '#2E8B57';
            ctx.lineWidth = 8;
            ctx.stroke();

            // Hoja
            if (progress > 0.5) {
                const leafY = y - stemHeightScaled * progress * 0.7;
                ctx.fillStyle = '#2E8B57';
                ctx.beginPath();
                ctx.moveTo(x + swayOffset, leafY);
                ctx.quadraticCurveTo(x + swayOffset - 30, leafY + 10, x + swayOffset - 5, leafY + 30);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(x + swayOffset, leafY + 10);
                ctx.quadraticCurveTo(x + swayOffset + 30, leafY + 20, x + swayOffset + 5, leafY + 40);
                ctx.fill();
            }

            // P√©talos y centro
            if (progress >= 1 && wiltProgress < 1) {
                for (let i = 0; i < numPetals; i++) {
                    const angle = (i / numPetals) * 2 * Math.PI;
                    ctx.save();
                    ctx.translate(x + swayOffset, y - stemHeightScaled);
                    ctx.rotate(angle);
                    
                    ctx.fillStyle = currentPetalColor;

                    if (petalShape === 'ellipse') {
                        ctx.beginPath();
                        ctx.ellipse(petalLengthScaled / 2, 0, petalLengthScaled / 2, petalWidthScaled / 2, 0, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (petalShape === 'triangle') {
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(petalLengthScaled, 0);
                        ctx.lineTo(petalLengthScaled / 2, petalWidthScaled);
                        ctx.closePath();
                        ctx.fill();
                    } else if (petalShape === 'square') {
                        ctx.beginPath();
                        ctx.rect(0, 0, petalLengthScaled, petalWidthScaled);
                        ctx.fill();
                    } else if (petalShape === 'heart') {
                        ctx.beginPath();
                        ctx.moveTo(0, petalLengthScaled / 4);
                        ctx.bezierCurveTo(petalLengthScaled / 2, -petalLengthScaled / 4, petalLengthScaled, petalLengthScaled / 2, petalLengthScaled, petalWidthScaled);
                        ctx.bezierCurveTo(petalLengthScaled / 2, petalLengthScaled * 1.5, -petalLengthScaled / 2, petalLengthScaled / 2, 0, petalLengthScaled / 4);
                        ctx.fill();
                    } else if (petalShape === 'star') {
                        ctx.beginPath();
                        const spikes = 5;
                        const outerRadius = petalLengthScaled;
                        const innerRadius = petalLengthScaled / 2;
                        for (let j = 0; j < spikes; j++) {
                            let spikeAngle = (j * 2 * Math.PI / spikes) - Math.PI / 2;
                            let outerX = outerRadius * Math.cos(spikeAngle);
                            let outerY = outerRadius * Math.sin(spikeAngle);
                            let innerX = innerRadius * Math.cos(spikeAngle + Math.PI / spikes);
                            let innerY = innerRadius * Math.sin(spikeAngle + Math.PI / spikes);
                            if (j === 0) {
                                ctx.moveTo(outerX, outerY);
                            } else {
                                ctx.lineTo(outerX, outerY);
                            }
                            ctx.lineTo(innerX, innerY);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
                
                // Dibujar el centro
                ctx.beginPath();
                ctx.arc(x + swayOffset, y - stemHeightScaled, centerRadiusScaled, 0, 2 * Math.PI);
                ctx.fillStyle = centerColor;
                ctx.fill();
                ctx.strokeStyle = '#E6A500';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        // Dibuja una gota de lluvia
        function drawRaindrop(drop) {
            ctx.beginPath();
            ctx.moveTo(drop.x, drop.y);
            ctx.lineTo(drop.x, drop.y + 10);
            ctx.strokeStyle = `rgba(173, 216, 230, ${drop.opacity})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Dibuja una abeja (fauna)
        function drawBee(bee) {
            const { x, y, angle, wingFlap } = bee;
            const size = 10;
            const wingSize = 5;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 2);
            
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.ellipse(0, 0, size * 0.8, size * 0.6, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.fillRect(-size * 0.7, -size * 0.3, size * 0.4, size * 0.6);
            ctx.fillRect(size * 0.3, -size * 0.3, size * 0.4, size * 0.6);
            
            ctx.beginPath();
            ctx.arc(-size * 0.6, -size * 0.3, 1, 0, 2 * Math.PI);
            ctx.arc(-size * 0.6, 0.3, 1, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(200, 200, 200, 0.7)';
            ctx.beginPath();
            ctx.ellipse(-size * 0.3, -size * 0.7, wingSize, wingSize * 1.5, -Math.PI / 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(size * 0.3, -size * 0.7, wingSize, wingSize * 1.5, Math.PI / 4, 0, 2 * Math.PI);
            ctx.fill();

            ctx.restore();
        }

        // Dibuja una mariposa (nueva fauna)
        function drawButterfly(butterfly) {
            const { x, y, angle, wingFlap } = butterfly;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + Math.PI / 2);

            // Cuerpo
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.rect(-5, -15, 10, 30);
            ctx.fill();

            // Alas superiores
            const wingColor = butterfly.petalColor;
            ctx.fillStyle = wingColor;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(30, -50 + wingFlap, 50, -20, 60, 0);
            ctx.bezierCurveTo(50, 20, 30, 50 - wingFlap, 0, 0);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-30, -50 + wingFlap, -50, -20, -60, 0);
            ctx.bezierCurveTo(-50, 20, -30, 50 - wingFlap, 0, 0);
            ctx.fill();

            ctx.restore();
        }

        // Dibuja una lib√©lula
        function drawDragonfly(creature) {
            const { x, y, angle, wingFlap } = creature;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);

            // Cuerpo
            ctx.fillStyle = '#006400';
            ctx.beginPath();
            ctx.ellipse(0, 0, 4, 15, 0, 0, 2 * Math.PI);
            ctx.fill();

            // Alas transparentes
            ctx.fillStyle = 'rgba(173, 216, 230, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-10, -5, 10 + wingFlap, 20 + wingFlap, -Math.PI / 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(10, -5, 10 + wingFlap, 20 + wingFlap, Math.PI / 4, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.ellipse(-10, 5, 10 + wingFlap, 20 + wingFlap, -Math.PI / 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(10, 5, 10 + wingFlap, 20 + wingFlap, Math.PI / 4, 0, 2 * Math.PI);
            ctx.fill();

            ctx.restore();
        }

        // Dibuja una luci√©rnaga
        function drawFirefly(creature, time) {
            const { x, y, glowFactor } = creature;
            const glowSize = 5 + Math.sin(time * 0.01) * 2;
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();

            ctx.shadowColor = 'yellow';
            ctx.shadowBlur = glowSize * glowFactor;
            ctx.fillStyle = `rgba(255, 255, 0, ${glowFactor})`;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        function drawAll() {
            drawBackground();
            stars.forEach(drawStar);
            drawSunMoon();
            clouds.forEach(drawCloud);
            flowers.forEach(flower => drawFlower(flower, time));
            raindrops.forEach(drawRaindrop);
            fauna.forEach(creature => {
                if (creature.type === 'bee') {
                    drawBee(creature);
                } else if (creature.type === 'butterfly') {
                    drawButterfly(creature);
                } else if (creature.type === 'dragonfly') {
                    drawDragonfly(creature);
                } else if (creature.type === 'firefly') {
                    drawFirefly(creature, time);
                }
            });
        }

        function updateTitleVisibility() {
            if (dayNightProgress > 0.25 && dayNightProgress < 1) {
                gardenTitle.style.color = '#333';
            } else {
                gardenTitle.style.color = '#f0f0f0';
            }
        }
        
        // Genera un punto de destino aleatorio en el lienzo
        function getRandomTarget() {
            return {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.75,
            };
        }

        function spawnFauna() {
            const isDaytime = dayNightProgress > 0.25 && dayNightProgress < 1;
            
            const faunaTypes = isDaytime ? ['bee', 'butterfly'] : ['dragonfly', 'firefly'];
            const type = faunaTypes[Math.floor(Math.random() * faunaTypes.length)];
            
            const newCreature = {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height * 0.75,
                type: type,
                angle: Math.random() * Math.PI * 2,
                speed: type === 'butterfly' ? 1.5 : (type === 'firefly' ? 1 : 2),
                wingFlap: 0,
                glowFactor: 0,
                target: getRandomTarget(), 
            };
            
            if (type === 'butterfly') {
                newCreature.petalColor = petalColors[Math.floor(Math.random() * petalColors.length)];
            }
            
            fauna.push(newCreature);
        }

        function animate() {
            updateDayNightProgress();
            time = Date.now();
            if (currentAnimation) {
                currentAnimation.progress += 0.02;
                if (currentAnimation.progress >= 1) {
                    currentAnimation = null;
                }
            }

            faunaSpawnTimer += 1000/60; 
            if (faunaSpawnTimer > FAUNA_SPAWN_INTERVAL) {
                 spawnFauna();
                 faunaSpawnTimer = 0;
            }
            
            // L√≥gica de lluvia
            if (isRaining) {
                for (let i = 0; i < 5; i++) {
                    raindrops.push({
                        x: Math.random() * canvas.width,
                        y: 0,
                        speed: Math.random() * 3 + 2,
                        opacity: Math.random() * 0.5 + 0.3
                    });
                }
            }
            raindrops = raindrops.filter(drop => {
                drop.y += drop.speed;
                if (drop.y >= canvas.height) {
                    return false;
                }
                return true;
            });

            // L√≥gica de regeneraci√≥n de flores
            const deadFlowers = [];
            flowers.forEach(flower => {
                // Iniciar el marchitamiento si la flor est√° madura y la probabilidad se cumple
                if (flower.wiltProgress === 0 && flower.progress >= 1 && Math.random() < REGENERATION_PROBABILITY) {
                    flower.wiltProgress = 0.01;
                }
                // Animar el marchitamiento
                if (flower.wiltProgress > 0 && flower.wiltProgress < 1) {
                    flower.wiltProgress += WILT_SPEED;
                }
                // Si la flor est√° completamente marchita, se marca para ser eliminada
                if (flower.wiltProgress >= 1) {
                    deadFlowers.push(flower);
                }
            });
            
            // Eliminar las flores muertas y crear nuevas
            if (deadFlowers.length > 0) {
                flowers = flowers.filter(flower => !deadFlowers.includes(flower));
                deadFlowers.forEach(() => {
                    const newFlower = {
                        x: Math.random() * canvas.width,
                        y: Math.random() * (canvas.height - canvas.height * 0.75) + canvas.height * 0.75,
                        progress: 0,
                        petalShape: ['ellipse', 'triangle', 'square', 'heart', 'star'][Math.floor(Math.random() * 5)],
                        petalColor: petalColors[Math.floor(Math.random() * petalColors.length)],
                        centerColor: petalColors[Math.floor(Math.random() * petalColors.length)],
                        numPetals: Math.floor(Math.random() * 15) + 5,
                        petalLength: Math.random() * 50 + 20,
                        petalWidth: Math.random() * 30 + 10,
                        stemHeight: Math.random() * 120 + 80,
                        centerRadius: Math.random() * 10 + 5,
                        wiltProgress: 0, // Nuevo
                    };
                    flowers.push(newFlower);
                    currentAnimation = newFlower;
                });
            }

            // L√≥gica de la fauna (abejas, mariposas, etc.)
            fauna.forEach(creature => {
                // L√≥gica de movimiento
                const dx = creature.target.x - creature.x;
                const dy = creature.target.y - creature.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 5) {
                    creature.target = getRandomTarget();
                } else {
                    creature.x += dx / distance * creature.speed;
                    creature.y += dy / distance * creature.speed;
                    creature.angle = Math.atan2(dy, dx);
                }
                
                // L√≥gica de animaci√≥n espec√≠fica
                if (creature.type === 'butterfly' || creature.type === 'dragonfly') {
                    creature.wingFlap = Math.sin(time * 0.02) * 5;
                }

                if (creature.type === 'firefly') {
                    creature.glowFactor = 0.5 + Math.sin(time * 0.005) * 0.5;
                }
            });
            fauna = fauna.filter(creature => creature.y > -50);

            moveClouds();
            animateStars();
            updateTitleVisibility();
            drawAll();
            requestAnimationFrame(animate);
        }

        function saveFlower(flowerData) {
            flowers.push(flowerData);
        }

        function clearAllFlowers() {
            flowers = [];
            fauna = [];
        }

        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            generateClouds();
            generateStars();
            getSunriseSunset().then(() => {
                animate();
            });
            
            canvas.addEventListener('click', (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                if (!currentAnimation && y > canvas.height * 0.75) {
                    const petalShapes = ['ellipse', 'triangle', 'square', 'heart', 'star'];
                    const randomShape = petalShapes[Math.floor(Math.random() * petalShapes.length)];
                    const randomPetalColor = petalColors[Math.floor(Math.random() * petalColors.length)];
                    
                    const newFlower = {
                        x: x,
                        y: y,
                        progress: 0,
                        petalShape: randomShape,
                        petalColor: randomPetalColor,
                        centerColor: petalColors[Math.floor(Math.random() * petalColors.length)],
                        numPetals: Math.floor(Math.random() * 15) + 5,
                        petalLength: Math.random() * 50 + 20,
                        petalWidth: Math.random() * 30 + 10,
                        stemHeight: Math.random() * 120 + 80,
                        centerRadius: Math.random() * 10 + 5,
                        wiltProgress: 0, // Inicialmente la flor no se est√° marchitando
                    };

                    saveFlower(newFlower);
                    currentAnimation = newFlower;
                }
            });

            clearButton.addEventListener('click', () => {
                clearAllFlowers();
            });

            rainButton.addEventListener('click', () => {
                isRaining = !isRaining;
                playRainSound();
            });

            windButton.addEventListener('click', () => {
                isWindy = !isWindy;
                toggleWindSound();
            });
            
            downloadButton.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'jardin-de-noath.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
            
            window.addEventListener('resize', resizeCanvas);
        });
    </script>
</body>
</html>
